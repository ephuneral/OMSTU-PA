{% extends "/base.html" %}
{% block title %}Функции и рекурсия{% endblock %}
{% block body %}
    <div>
        <div class="page">
            <h1>Урок 8. Функции и рекурсия</h1>
            <h2>1. Функции</h2>
			<p>Напомним, что в математике факториал числа n определяется как n! = 1 ⋅ 2 ⋅ ... ⋅ n.
			Например, 5! = 1 ⋅ 2 ⋅ 3 ⋅ 4 ⋅ 5 = 120. Ясно, что факториал можно легко посчитать, воспользовавшись циклом for.
			Представим, что нам нужно в нашей программе вычислять факториал разных чисел несколько раз (или в разных местах кода).
			Конечно, можно написать вычисление факториала один раз, а затем используя Copy-Paste вставить его везде, где это будет нужно.</p>
			<iframe src="https://trinket.io/embed/python/3a2ad8eb44" width="100%" height="356" frameborder="0" marginwidth="0" marginheight="0" allowfullscreen></iframe>
			<p>Однако, если мы ошибёмся один раз в начальном коде, то потом эта ошибка попадёт в код во все места, куда мы скопировали вычисление факториала.
			Да и вообще, код занимает больше места, чем мог бы. Чтобы избежать повторного написания одной и той же логики, в языках программирования существуют функции.</p>
			<p> Функции — это такие участки кода, которые изолированы от остальный программы и выполняются только тогда, когда вызываются.
			Вы уже встречались с функциями sqrt(), len() и print(). Они все обладают общим свойством: они могут принимать параметры (ноль, один или несколько),
			и они могут возвращать значение (хотя могут и не возвращать). Например, функция sqrt() принимает один параметр и возвращает значение (корень числа).
			Функция print() принимает переменное число параметров и ничего не возвращает.</p>
			<p> Покажем, как написать функцию factorial(), которая принимает один параметр — число, и возвращает значение — факториал этого числа.</p>
			<iframe src="https://trinket.io/embed/python/cf6c2ee1bb" width="100%" height="356" frameborder="0" marginwidth="0" marginheight="0" allowfullscreen></iframe>
			<p>Дадим несколько объяснений. Во-первых, код функции должен размещаться в начале программы, вернее, до того места, где мы захотим воспользоваться функцией factorial().
			Первая строчка этого примера является описанием нашей функции. factorial — идентификатор, то есть имя нашей функции.
			После идентификатора в круглых скобках идет список параметров, которые получает наша функция. Список состоит из перечисленных через запятую идентификаторов параметров.
			В нашем случае список состоит из одной величины n. В конце строки ставится двоеточие.</p>
			<p> Далее идет тело функции, оформленное в виде блока, то есть с отступом. Внутри функции вычисляется значение факториала числа n и оно сохраняется в переменной res.
			Функция завершается инструкцией return res, которая завершает работу функции и возвращает значение переменной res.</p>
			<p> Инструкция return может встречаться в произвольном месте функции, ее исполнение завершает работу функции и возвращает указанное значение в место вызова.
			Если функция не возвращает значения, то инструкция return используется без возвращаемого значения.
			В функциях, которым не нужно возвращать значения, инструкция return может отсутствовать.</p>
			<p>Приведём ещё один пример. Напишем функцию max(), которая принимает два числа и возвращает максимальное из них 
			(на самом деле, такая функция уже встроена в Питон).</p>
			<iframe src="https://trinket.io/embed/python/d490168919" width="100%" height="356" frameborder="0" marginwidth="0" marginheight="0" allowfullscreen></iframe>
			<p>Теперь можно написать функцию max3(), которая принимает три числа и возвращает максимальное их них.</p>
			<iframe src="https://trinket.io/embed/python/6f4aceeadd" width="100%" height="356" frameborder="0" marginwidth="0" marginheight="0" allowfullscreen></iframe>
			<p>Встроенная функция max() в Питоне может принимать переменное число аргументов и возвращать максимум из них. 
			Приведём пример того, как такая функция может быть написана</p>
			<iframe src="https://trinket.io/embed/python/88326f0a76" width="100%" height="356" frameborder="0" marginwidth="0" marginheight="0" allowfullscreen></iframe>
			<p>Все переданные в эту функцию параметры соберутся в один кортеж с именем a, на что указывает звёздочка в строке объявления функции.</p>
			<h2>2. Локальные и глобальные переменные</h2>
			<p>Внутри функции можно использовать переменные, объявленные вне этой функции</p>
			<iframe src="https://trinket.io/embed/python/b191081a8c" width="100%" height="356" frameborder="0" marginwidth="0" marginheight="0" allowfullscreen></iframe>
			<p>Здесь переменной <code style = "color:#22A10A">a</code> присваивается значение 1, и функция <code style = "color:#22A10A">f()</code> печатает это значение, несмотря на то, что до объявления функции <code style = "color:#22A10A">f</code> эта переменная не инициализируется.
			В момент вызова функции <code style = "color:#22A10A">f()</code> переменной a уже присвоено значение, поэтому функция <code style = "color:#22A10A">f()</code> может вывести его на экран.</p>
			<p> Такие переменные (объявленные вне функции, но доступные внутри функции) называются глобальными.</p>
			<p> Но если инициализировать какую-то переменную внутри функции, использовать эту переменную вне функции не удастся. Например:</p>
			<iframe src="https://trinket.io/embed/python/98d155cc3f" width="100%" height="356" frameborder="0" marginwidth="0" marginheight="0" allowfullscreen></iframe>
			<p>Получим ошибку <code style = "color:#22A10A">NameError: name 'a' is not defined</code>. Такие переменные, объявленные внутри функции, называются локальными.
			Эти переменные становятся недоступными после выхода из функции. Интересным получится результат, 
			если попробовать изменить значение глобальной переменной внутри функции:</p>
			<iframe src="https://trinket.io/embed/python/52f22ecca9" width="100%" height="356" frameborder="0" marginwidth="0" marginheight="0" allowfullscreen></iframe>
			<p>Будут выведены числа 1 и 0. Несмотря на то, что значение переменной <code style = "color:#22A10A">a</code> изменилось внутри функции, вне функции оно осталось прежним!
			Это сделано в целях “защиты” глобальных переменных от случайного изменения из функции. Например, если функция будет вызвана из цикла 
			по переменной <code style = "color:#22A10A">i</code>, а в этой функции будет использована переменная <code style = "color:#22A10A">i</code> также для организации цикла, то эти переменные должны быть различными.
			Если вы не поняли последнее предложение, то посмотрите на следующий код и подумайте, как бы он работал, 
			если бы внутри функции изменялась переменная <code style = "color:#22A10A">i</code>.</p>
			<iframe src="https://trinket.io/embed/python/9313c47617" width="100%" height="356" frameborder="0" marginwidth="0" marginheight="0" allowfullscreen></iframe>
			<p>Если бы глобальная переменная <code style = "color:#22A10A">i</code> изменялась внутри функции, то мы бы получили вот что:</p>
			<iframe src="https://trinket.io/embed/python/e0f19d62e6" width="100%" height="356" frameborder="0" marginwidth="0" marginheight="0" allowfullscreen></iframe>
			<p>Итак, если внутри функции модифицируется значение некоторой переменной, то переменная с таким именем становится локальной переменной,
			и ее модификация не приведет к изменению глобальной переменной с таким же именем.</p>
			<p> Более формально: интерпретатор Питон считает переменную локальной для данной функции, если в её коде есть хотя бы одна инструкция,
			модифицирующая значение переменной, то эта переменная считается локальной и не может быть использована до инициализации. 
			Инструкция, модифицирующая значение переменной — это операторы <code style = "color:#22A10A">=</code>, <code style = "color:#22A10A">+=</code>, а также использование переменной в качестве параметра цикла <code style = "color:#22A10A">for</code>.
			При этом даже если инструкция, модицифицирующая переменную никогда не будет выполнена, интерпретатор это проверить не может,
			и переменная все равно считается локальной. Пример:</p>
			<iframe src="https://trinket.io/embed/python/ab4cfb1e7b" width="100%" height="356" frameborder="0" marginwidth="0" marginheight="0" allowfullscreen></iframe>
			<p>Возникает ошибка: <code style = "color:#22A10A">UnboundLocalError: local variable 'a' referenced before assignment</code>. А именно, в функции <code style = "color:#22A10A">f()</code> идентификатор <code style = "color:#22A10A">a</code> становится локальной переменной, т.к.
			в функции есть команда, модифицирующая переменную <code style = "color:#22A10A">a</code>, пусть даже никогда и не выполняющийся (но интерпретатор не может это отследить).
			Поэтому вывод переменной <code style = "color:#22A10A">a</code> приводит к обращению к неинициализированной локальной переменной.<p>
			</p> Чтобы функция могла изменить значение глобальной переменной, необходимо объявить эту переменную внутри функции, как глобальную, при помощи ключевого слова <code style = "color:#22A10A">global</code>:</p>
			<iframe src="https://trinket.io/embed/python/3d35a74283" width="100%" height="356" frameborder="0" marginwidth="0" marginheight="0" allowfullscreen></iframe>
			<p>В этом примере на экран будет выведено 1 1, так как переменная <code style = "color:#22A10A">a</code> объявлена, как глобальная, и ее изменение внутри функции приводит к тому,
			что и вне функции переменная будет доступна.</p>
			<p> Тем не менее, лучше не изменять значения глобальных переменных внутри функции. Если ваша функция должна поменять какую-то переменную,
			пусть лучше она вернёт это значением, и вы сами при вызове функции явно присвоите в переменную это значение. Если следовать этим правилам,
			то функции получаются независимыми от кода, и их можно легко копировать из одной программы в другую.</p>
			<p> Например, пусть ваша программа должна посчитать факториал вводимого числа, который вы потом захотите сохранить в переменной f. 
			Вот как это не стоит делать:</p>
			<iframe src="https://trinket.io/embed/python/e8482ac035" width="100%" height="356" frameborder="0" marginwidth="0" marginheight="0" allowfullscreen></iframe>
			<p>Этот код написан плохо, потому что его трудно использовать ещё один раз. Если вам завтра понадобится в другой программе использовать функцию «факториал»,
			то вы не сможете просто скопировать эту функцию отсюда и вставить в вашу новую программу. Вам придётся поменять то, как она возвращает посчитанное значение.</p>
			<p> Гораздо лучше переписать этот пример так:</p>
			<iframe src="https://trinket.io/embed/python/2ec7b3eb96" width="100%" height="356" frameborder="0" marginwidth="0" marginheight="0" allowfullscreen></iframe>
			<p>Если нужно, чтобы функция вернула не одно значение, а два или более, то для этого функция может вернуть список из двух или нескольких значений:</p>
			<iframe src="https://trinket.io/embed/python/e7bba8fd80" width="100%" height="356" frameborder="0" marginwidth="0" marginheight="0" allowfullscreen></iframe>
			<p>Тогда результат вызова функции можно будет использовать во множественном присваивании:</p>
			<iframe src="https://trinket.io/embed/python/d1f495a22b" width="100%" height="356" frameborder="0" marginwidth="0" marginheight="0" allowfullscreen></iframe>
			<h2>3. Рекурсия</h2>
			<iframe src="https://trinket.io/embed/python/0cc72d25f4" width="100%" height="356" frameborder="0" marginwidth="0" marginheight="0" allowfullscreen></iframe>
			<p>Как мы видели выше, функция может вызывать другую функцию. Но функция также может вызывать и саму себя!
			Рассмотрим это на примере функции вычисления факториала. Хорошо известно, что 0!=1, 1!=1. А как вычислить величину n!
			для большого n? Если бы мы могли вычислить величину (n-1)!, то тогда мы легко вычислим n!, поскольку n!=n⋅(n-1)!.
			Но как вычислить (n-1)!? Если бы мы вычислили (n-2)!, то мы сможем вычисли и (n-1)!=(n-1)⋅(n-2)!. А как вычислить (n-2)!?
			Если бы... В конце концов, мы дойдем до величины 0!, которая равна 1. Таким образом, для вычисления факториала
			мы можем использовать значение факториала для меньшего числа. Это можно сделать и в программе на Питоне:</p>
			<iframe src="https://trinket.io/embed/python/f65b20a3b0" width="100%" height="356" frameborder="0" marginwidth="0" marginheight="0" allowfullscreen></iframe>
			<p>Подобный прием (вызов функцией самой себя) называется рекурсией, а сама функция называется рекурсивной.</p>
			<p> Рекурсивные функции являются мощным механизмом в программировании. К сожалению, они не всегда эффективны. 
			Также часто использование рекурсии приводит к ошибкам. Наиболее распространенная из таких ошибок – бесконечная рекурсия,
			когда цепочка вызовов функций никогда не завершается и продолжается, пока не кончится свободная память в компьютере. 
			Пример бесконечной рекурсии приведен в эпиграфе к этому разделу. Две наиболее распространенные причины для бесконечной рекурсии:</p>
			<p> 1. Неправильное оформление выхода из рекурсии. Например, если мы в программе вычисления факториала забудем поставить проверку
			<code style = "color:#22A10A">if n == 0</code>, то <code style = "color:#22A10A">factorial(0)</code> вызовет <code style = "color:#22A10A">factorial(-1)</code>,
			тот вызовет <code style = "color:#22A10A">factorial(-2)</code> и т. д. 2. Рекурсивный вызов с неправильными параметрами.
			Например, если функция <code style = "color:#22A10A">factorial(n)</code> будет вызывать <code style = "color:#22A10A">factorial(n)</code>, то также получится бесконечная цепочка.</p>
			<p> Поэтому при разработке рекурсивной функции необходимо прежде всего оформлять условия завершения рекурсии и думать, почему рекурсия когда-либо завершит работу.</p>
        </div>
    </div>
{% endblock %}       